// ==UserScript==
// @name         Kour Websocket
// @match        *://kour.io/*
// @run-at       document-start
// @grant        unsafeWindow
// ==/UserScript==

// Not done at all, just a idea of what needs be done.

if(unsafeWindow.location.href.indexOf( "/a" ) != -1) {
    unsafeWindow.location.href = "https://kour.io";
}

class GpBinaryV18 {
    constructor() {
        this.rtsMessageType = {
            Init: 0,
            InitResponse: 1,
            Operation: 2,
            OperationResponse: 3,
            Event: 4,
            DisconnectMessage: 5,
            InternalOperationRequest: 6,
            InternalOperationResponse: 7,
            Message: 8,
            RawMessage: 9,
            Unknown: 255
        };

        this.gpTypeV18 = {
            Unknown: 0,
            Boolean: 2,
            Byte: 3,
            Short: 4,
            Float: 5,
            Double: 6,
            String: 7,
            Null: 8,
            CompressedInt: 9,
            CompressedLong: 10,
            Int1: 11,
            Int1_: 12,
            Int2: 13,
            Int2_: 14,
            L1: 15,
            L1_: 16,
            L2: 17,
            L2_: 18,
            Custom: 19,
            Dictionary: 20,
            Hashtable: 21,
            ObjectArray: 23,
            OperationRequest: 24,
            OperationResponse: 25,
            EventData: 26,
            BooleanFalse: 27,
            BooleanTrue: 28,
            ShortZero: 29,
            IntZero: 30,
            LongZero: 31,
            FloatZero: 32,
            DoubleZero: 33,
            ByteZero: 34,
            Array: 64,
            BooleanArray: 66,
            ByteArray: 67,
            ShortArray: 68,
            DoubleArray: 70,
            FloatArray: 69,
            StringArray: 71,
            HashtableArray: 85,
            DictionaryArray: 84,
            CustomTypeArray: 83,
            CompressedIntArray: 73,
            CompressedLongArray: 74,
            CustomTypeSlim: 128
        };

        this.readDelegates = {
            8: function(data) {
                return { success: true, result: null };
            },
            2: function(data) {
                /*
        readDelegates[2] = delegate (ref ReadContext context, out object result, out string errorMsg, int depth)
        {
            if (!LittleEndianReader.TryReadBoolean(context.data, ref context.offset, out result))
            {
                errorMsg = string.Format("Not enough data to read {0}", "Boolean");
                return false;
            }

            errorMsg = string.Empty;
            return true;
        };
                */
            },
            27: function(data) {
                return { success: true, result: false };
            },
            28: function(data) {
                return { success: true, result: true };
            },
            3: function(data) {
                /*
        readDelegates[3] = delegate (ref ReadContext context, out object result, out string errorMsg, int depth)
        {
            if (!LittleEndianReader.TryReadByte(context.data, ref context.offset, out result))
            {
                errorMsg = string.Format("Not enough data to read {0}", "Byte");
                return false;
            }

            errorMsg = string.Empty;
            return true;
        };
                */
            },
            4: function(data) {
                /*
        readDelegates[4] = delegate (ref ReadContext context, out object result, out string errorMsg, int depth)
        {
            if (!LittleEndianReader.TryReadInt16(context.data, ref context.offset, out result))
            {
                errorMsg = string.Format("Not enough data to read {0}", "Short");
                return false;
            }

            errorMsg = string.Empty;
            return true;
        };
                */
            },
            29: function(data) {
                return { success: true, result: 0 }; //int16
            },
            30: function(data) {
                return { success: true, result: 0 };
            },
            31: function(data) {
                return { success: true, result: 0 }; // int64
            },
            32: function(data) {
                return { success: true, result: 0 }; // System.Single
            },
            33: function(data) {
                return { success: true, result: 0.0 };
            },
            34: function(data) {
                return { success: true, result: 0 };
            },
            5: function(data) {
                /*
        readDelegates[5] = delegate (ref ReadContext context, out object result, out string errorMsg, int depth)
        {
            if (!LittleEndianReader.TryReadSingle(context.data, ref context.offset, out result))
            {
                errorMsg = string.Format("Not enough data to read {0}", "Float");
                return false;
            }

            errorMsg = string.Empty;
            return true;
        };
                */
            },
            6: function(data) {
                /*
        readDelegates[6] = delegate (ref ReadContext context, out object result, out string errorMsg, int depth)
        {
            if (!LittleEndianReader.TryReadDouble(context.data, ref context.offset, out result))
            {
                errorMsg = string.Format("Not enough data to read {0}", "Double");
                return false;
            }

            errorMsg = string.Empty;
            return true;
        };
                */
            },
            7: function(data) {
                // ReadString
            },
            21: function(data) {
                // ReadHashTable
            },
            20: function(data) {
                // ReadDictionary
            },
            19: function(data) {
                // ReadCustomType
            },
            11: function(data) {
                // TryReadInt1
            },
            13: function(data) {
                // TryReadInt2
            },
            12: function(data) {
                // TryReadInt1_
            },
            14: function(data) {
                // TryReadInt2_
            },
            15: function(data) {
                // TryReadL1
            },
            17: function(data) {
                // TryReadL2
            },
            16: function(data) {
                // TryReadL1_
            },
            18: function(data) {
                // TryReadL2_
            },
            9: function(data) {
                // TryReadCompressedInt32
            },
            10: function(data) {
                // TryReadCompressedInt64
            },
            66: function(data) {
                // TryReadBooleanArray
            },
            67: function(data) {
                // ReadByteArray
            },
            68: function(data) {
                // TryReadInt16Array
            },
            70: function(data) {
                // TryReadDoubleArray
            },
            69: function(data) {
                // TryReadSingleArray
            },
            71: function(data) {
                // TryReadStringArray
            },
            23: function(data) {
                // ReadObjectArray
            },
            85: function(data) {
                // TryReadHashtableArray
            },
            84: function(data) {
                // TryReadDictionaryArray
            },
            83: function(data) {
                // ReadCustomTypeArray
            },
            73: function(data) {
                // TryReadCompressedInt32Array
            },
            74: function(data) {
                // TryReadCompressedInt64Array
            },
            64: function(data) {
                // TryReadArrayInArray
            }
        };

        for (let i = 128; i < 228; i++) {
            this.readDelegates[i] = function(data) {
                // ReadSlimCustomType
            };
        }
    }

    tryParseMessageHeader(data) {
        if (data.length < 2 || data[0] !== 243) {
            return { success: false, header: null };
        }

        const header = {
            magicByte: 243,
            messageType: Object.keys(this.rtsMessageType).find(key => this.rtsMessageType[key] === data[1] & 0x7F),
            isEncrypted: !!(data[1] & 0x80),
            sizeInBytes: data[2]
        };

        return { success: true, header };
    }

    tryParseOperationRequest(data) {
        let offset = 2;

        const b = data[offset]
        const b2 = data[offset + 1];

        offset++;

        const requestDataSize = data.Length - offset;

        let num = 0;
        while (num < b2) {
            const offset2 = offset;
            const protocolType = Object.keys(this.gpTypeV18).find(key => this.gpTypeV18[key] === data[offset]);
            const protocolTypeInt = data[offset];
            offset++;

            // depth = 1

            //console.log(protocolType, protocolTypeInt);
            num++;
        }

        return { operationCode: b };
    }
}

unsafeWindow.WebSocket = class extends WebSocket {
    constructor(...args) {
        super(...args);

        //this.addEventListener("message", async ({ data }) => {
        //    const gp = new GpBinaryV18();
        //    const header = gp.tryParseMessageHeader(new Uint8Array(data));
        //    console.info("%c <= ", "background:#FF6A19;color:#000", header);
        //});
    }

    send(data) {
        console.log(data);
        console.log(new Uint8Array(data));
        const gp = new GpBinaryV18();
        const header = gp.tryParseMessageHeader(new Uint8Array(data));

        if (header.header.messageType == "Operation") {
            gp.tryParseOperationRequest(new Uint8Array(data));
        }

        console.info("%c => ", "background:#7F7;color:#000", header.header.messageType);
        return super.send(data);
    }
}
